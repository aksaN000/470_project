// üõ°Ô∏è Report Model (MVC - Model Layer)
// This defines the structure for content reporting and moderation

const mongoose = require('mongoose');

// Define the Report schema
const reportSchema = new mongoose.Schema({
    // Reporter information
    reporter: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: [true, 'Reporter is required']
    },
    
    // What is being reported
    reportType: {
        type: String,
        enum: ['meme', 'comment', 'user'],
        required: [true, 'Report type is required']
    },
    
    // Reference to the reported content
    reportedContent: {
        meme: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Meme'
        },
        comment: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Comment'
        },
        user: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User'
        }
    },
    
    // Reason for reporting
    reason: {
        type: String,
        enum: [
            'spam',
            'harassment',
            'hate_speech',
            'inappropriate_content',
            'copyright_violation',
            'misinformation',
            'violence',
            'adult_content',
            'self_harm',
            'other'
        ],
        required: [true, 'Reason is required']
    },
    
    // Additional details
    description: {
        type: String,
        maxlength: [500, 'Description cannot exceed 500 characters'],
        trim: true
    },
    
    // Report status
    status: {
        type: String,
        enum: ['pending', 'under_review', 'resolved', 'dismissed'],
        default: 'pending'
    },
    
    // Priority level
    priority: {
        type: String,
        enum: ['low', 'medium', 'high', 'critical'],
        default: 'medium'
    },
    
    // Moderation information
    moderation: {
        reviewedBy: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User'
        },
        reviewedAt: {
            type: Date
        },
        action: {
            type: String,
            enum: [
                'no_action',
                'content_removed',
                'content_flagged',
                'user_warned',
                'user_suspended',
                'user_banned'
            ]
        },
        notes: {
            type: String,
            maxlength: [1000, 'Notes cannot exceed 1000 characters']
        },
        evidence: [{
            type: String,
            description: String,
            uploadedAt: {
                type: Date,
                default: Date.now
            }
        }]
    },
    
    // Automation flags
    isAutoGenerated: {
        type: Boolean,
        default: false
    },
    
    autoDetectionScore: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
    },
    
    // Tracking
    viewedBy: [{
        user: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'User'
        },
        viewedAt: {
            type: Date,
            default: Date.now
        }
    }],
    
    // Resolution tracking
    resolvedAt: {
        type: Date
    },
    
    escalatedTo: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    
    escalatedAt: {
        type: Date
    }
}, {
    timestamps: true
});

// Compound indexes for efficient queries
reportSchema.index({ status: 1, createdAt: -1 });
reportSchema.index({ reportType: 1, status: 1 });
reportSchema.index({ reporter: 1, createdAt: -1 });
reportSchema.index({ priority: 1, status: 1, createdAt: -1 });
reportSchema.index({ 'moderation.reviewedBy': 1, 'moderation.reviewedAt': -1 });

// Static methods
reportSchema.statics.getReportStats = async function() {
    return await this.aggregate([
        {
            $group: {
                _id: '$status',
                count: { $sum: 1 }
            }
        }
    ]);
};

reportSchema.statics.getPendingReportsCount = async function() {
    return await this.countDocuments({ status: 'pending' });
};

reportSchema.statics.getReportsByType = async function() {
    return await this.aggregate([
        {
            $group: {
                _id: '$reportType',
                count: { $sum: 1 },
                pending: {
                    $sum: { $cond: [{ $eq: ['$status', 'pending'] }, 1, 0] }
                }
            }
        }
    ]);
};

// Instance methods
reportSchema.methods.markAsReviewed = async function(reviewerId, action, notes) {
    this.status = 'under_review';
    this.moderation.reviewedBy = reviewerId;
    this.moderation.reviewedAt = new Date();
    this.moderation.action = action;
    this.moderation.notes = notes;
    
    return await this.save();
};

reportSchema.methods.resolve = async function(action, notes) {
    this.status = 'resolved';
    this.resolvedAt = new Date();
    if (action) this.moderation.action = action;
    if (notes) this.moderation.notes = notes;
    
    return await this.save();
};

reportSchema.methods.dismiss = async function(notes) {
    this.status = 'dismissed';
    this.resolvedAt = new Date();
    this.moderation.action = 'no_action';
    if (notes) this.moderation.notes = notes;
    
    return await this.save();
};

reportSchema.methods.escalate = async function(escalateTo) {
    this.priority = 'critical';
    this.escalatedTo = escalateTo;
    this.escalatedAt = new Date();
    
    return await this.save();
};

// Pre-save middleware
reportSchema.pre('save', function(next) {
    // Auto-set priority based on reason
    if (this.isNew) {
        const highPriorityReasons = ['hate_speech', 'violence', 'self_harm'];
        const criticalReasons = ['harassment'];
        
        if (criticalReasons.includes(this.reason)) {
            this.priority = 'critical';
        } else if (highPriorityReasons.includes(this.reason)) {
            this.priority = 'high';
        }
    }
    
    next();
});

// Post-save middleware for notifications
reportSchema.post('save', async function(doc) {
    // Here you could trigger notifications to moderators
    // For high priority reports, send immediate notifications
    if (doc.priority === 'critical' && doc.status === 'pending') {
        // TODO: Send notification to moderators
        console.log(`üö® Critical report received: ${doc._id}`);
    }
});

// Export the Report model
module.exports = mongoose.model('Report', reportSchema);
